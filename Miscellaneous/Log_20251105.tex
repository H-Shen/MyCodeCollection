\documentclass[11pt,a4paper]{article}
\usepackage[margin=2.3cm]{geometry}
\usepackage{fontspec}
\newfontfamily\codefont{JetBrains Mono}

\usepackage{expl3}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{caption}
\usepackage{fancyhdr}

% --- Page style ---
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\texttt{From Shell to Binary}}
\fancyhead[R]{\texttt{November 2025}}
\fancyfoot[C]{\thepage}

\setstretch{1.2}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  urlcolor=blue,
  citecolor=black
}

% --- Code style ---
\definecolor{lightgray}{rgb}{0.96,0.96,0.96}
\definecolor{deepblue}{rgb}{0.13,0.13,0.73}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.45,0}
\definecolor{darkgray}{rgb}{0.3,0.3,0.3}

\lstset{
  backgroundcolor=\color{lightgray},
  basicstyle=\codefont\footnotesize,
  frame=single,
  rulecolor=\color{gray},
  breaklines=true,
  breakatwhitespace=true,
  showstringspaces=false,
  commentstyle=\color{deepgreen},
  keywordstyle=\color{deepblue}\bfseries,
  stringstyle=\color{deepred},
  tabsize=4,
  columns=fullflexible,
  keepspaces=true
}

\lstdefinestyle{bash}{language=bash}
\lstdefinestyle{go}{language=go}

% --- Hex numbering ---
\ExplSyntaxOn
\newcommand{\hexnum}[1]{\int_to_Hex:n { #1 }}
\newcommand{\hexsection}{\hexnum{\value{section}}}
\ExplSyntaxOff

\titleformat{\section}
  {\normalfont\ttfamily\LARGE}
  {\texttt{0x\hexsection}}
  {1em}
  {\bfseries}
  []
\titlespacing*{\section}{0pt}{1.2ex plus 1ex minus .2ex}{0.8ex}

\title{\textbf{From Shell to Binary: Simple Local Field Encryption for Notion Workflows}}
\author{}
\date{}

\begin{document}
\maketitle

\section*{0x0 Context: Job Systems, Notion, and the Problem of Trust}

While managing a job-hunting pipeline within Notion—tracking companies, portals, and credential states—the same flaw repeated itself:  
each platform demanded yet another isolated login.  
Passwords multiplied faster than interviews, and the ``management'' problem outgrew any browser extension.

Notion became the data hub, but also the weakest link:  
its tables stored plaintext, its encryption model was closed-source,  
and ``zero-trust'' meant trusting someone else's zero.  

The requirement was simple but absolute:  
store credentials inside Notion, but never in plaintext.  
Encryption had to happen locally, offline, reversible, and reproducible.

\section*{0x1 First Attempt: The Shell Script Era}

A Bash prototype looked elegant:

\begin{lstlisting}[style=bash,caption={Initial Bash prototype}]
#!/bin/bash
gpg --armor --encrypt -r "$1" <<< "$2"
\end{lstlisting}

It worked—until whitespace appeared.  
Different shells (\texttt{bash}, \texttt{zsh}, \texttt{fish}) interpreted quoting rules differently; clipboard utilities truncated output streams; newline handling corrupted armored blocks.  
Debugging became ritual suffering.

Worse, portability vanished across systems:
\begin{itemize}
  \item macOS vs Linux: inconsistent redirection semantics;
  \item Dependency drift: \texttt{gpg} vs \texttt{gpg2};
  \item Shell injection risks under weak sanitization.
\end{itemize}

The design violated the first principle of secure tooling:  
\textbf{determinism over convenience.}  
Thus the migration—to a compiled, reproducible binary—became inevitable.

\section*{0x2 Why Go: Static Control and Binary Hygiene}

Go was chosen for its operational determinism rather than speed:
\begin{itemize}
  \item Portable, statically linked, zero-runtime dependency;
  \item Context-based timeout control;
  \item Simple cross-compilation for Darwin, Linux, Windows;
  \item Binary hygiene: trimpath, no build ID, stripped symbols;
  \item Excellent subprocess and I/O support.
\end{itemize}

The tool had to behave identically across environments—  
no shell aliases, no environment inheritance, no hidden state.  
It would operate like a utility: precise, deterministic, and quiet.

\section*{0x3 Clean Build Chain}

\begin{lstlisting}[style=bash,caption={Static release build}]
env GO111MODULE=off GOOS=darwin GOARCH=amd64 CGO_ENABLED=0 \
  go build -ldflags="-s -w -buildid=" -trimpath -o notioncrypt notioncrypt.go
\end{lstlisting}

Flags removed paths and symbols, ensuring auditability.

\begin{lstlisting}[style=bash]
strings notioncrypt | grep -E "Users|src|go:"
\end{lstlisting}

No leakage, no traces, no excuses.

\section*{0x4 The UPX Trap}

Compression was tested once—then never again:

\begin{lstlisting}[style=bash]
upx --best --lzma notioncrypt
./notioncrypt --help
# -> trace trap
\end{lstlisting}

At first glance it looked like a bad compression build,  
but the truth was more architectural.

To verify, a debugging session was started:

\begin{lstlisting}[style=bash,caption={Debugging the trap with LLDB}]
lldb ./notioncrypt
(lldb) target create "./notioncrypt"
(lldb) run --help
Process 32809 launched: '/home/scripts/notioncrypt' (x86_64)
Process 32809 stopped
* thread #1, stop reason = EXC_BREAKPOINT (code=EXC_I386_BPT, subcode=0x0)
    frame #0: 0x00000000010c9301 notioncrypt
->  0x10c9301: callq  0x10c95c0
    0x10c9306: pushq  %rbp
    0x10c9307: pushq  %rbx
    0x10c9308: pushq  %rcx
\end{lstlisting}

\texttt{lldb} confirmed: \texttt{EXC\_BREAKPOINT}.  
macOS AMFI blocked self-decompression memory.  
The conclusion was instant: anti-tamper protections can turn inward.  
UPX saved kilobytes but cost predictability.  
Lesson: \textit{smaller is not safer.}

\section*{0x5 GPG as Subprocess, Not Library}

Instead of embedding OpenPGP libraries, GPG was treated as an external primitive.  
Advantages:
\begin{itemize}
  \item Full compatibility with system keyrings;
  \item Avoids static crypto dependencies;
  \item Predictable I/O and isolated state.
\end{itemize}

Neutral test keys—\texttt{anonymous <anonymous@local>}—were generated.  
RSA-4096, no passphrase, local scope only.

\section*{0x6 Determinism and Error Design}

All failure modes were enumerated explicitly, returning numeric codes for scripting reliability.  
Timeouts, invalid input, missing binaries, and size overruns are classified distinctly.  

This explicit taxonomy was not aesthetic; it was operational.  
By aligning exit codes to deterministic categories, the binary became composable within CI pipelines and shell automation—no silent failures, no undefined states.

\section*{0x7 Practical Workflow}

\begin{lstlisting}[style=bash,caption={Encrypt to clipboard}]
./notioncrypt -e 3F1BB7201ADC1B56ED47D8A39E49C9D917A0CFFC "hunter2" | pbcopy
\end{lstlisting}

\begin{lstlisting}[style=bash,caption={Decrypt from clipboard}]
pbpaste | ./notioncrypt -d 3F1BB7201ADC1B56ED47D8A39E49C9D917A0CFFC # -> hunter2
\end{lstlisting}

Offline, stateless, reversible—clipboard as transport, Notion as inert storage.

\section*{0x8 Reflection: Systems, Attack Surfaces, and Agency}

The evolution from Bash to Go to GPG subprocess mirrors a larger truth:  
modern SaaS erodes user control through abstraction.  
By building local encryption with no telemetry, no auth, and no API keys, one reclaims a fragment of computational agency.  

\medskip
\textit{This binary began as convenience; it ended as philosophy.}

\begin{flushright}
November 5, 2025\\
Prince George, BC
\end{flushright}

\appendix
\section*{Appendix A: Complete Go Implementation}

Below is the final iteration of the Go implementation—clean, stateless, and fully auditable.

\lstset{frame=none}
\begin{lstlisting}[style=go]
package main

// Build instructions for different platforms:
//
// macOS (Darwin) amd64:
//   env GO111MODULE=off GOOS=darwin GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w -buildid=" -trimpath -o notioncrypt notioncrypt.go
//
// Linux amd64:
//   env GO111MODULE=off GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w -buildid=" -trimpath -o notioncrypt notioncrypt.go
//
// Windows amd64:
//   env GO111MODULE=off GOOS=windows GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w -buildid=" -trimpath -o notioncrypt.exe notioncrypt.go

import (
	"bufio"
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
	"unicode/utf8"
)

// Exit codes returned by the program to indicate different error conditions
const (
	ExitSuccess = iota // Operation completed successfully
	ExitUsage          // Invalid command-line arguments or usage
	ExitGPGNotFound    // GPG executable not found in PATH
	ExitFormatInvalid  // Input format validation failed
	ExitLengthInvalid  // Input length exceeds limits
	ExitEncryptFail    // Encryption operation failed
	ExitReadFail       // Failed to read from stdin
	ExitNoCiphertext   // No ciphertext data provided
	ExitDecryptFail    // Decryption operation failed
)

const (
	maxPlaintextBytes  = 8 * 1024        // Maximum plaintext size: 8 KB
	maxCiphertextBytes = 64 * 1024       // Maximum ciphertext size: 64 KB
	maxKeyLength       = 1024            // Maximum length for key ID or file path
	maxKeyFileSize     = 1024 * 1024     // Maximum key file size: 1 MB
	gpgTimeout         = 10 * time.Second // Timeout for GPG operations
	minGPGKeyIDLength  = 8               // Minimum GPG key ID length (short format)
)

// ValidationError represents an input validation failure
type ValidationError struct {
	Field  string // The field that failed validation
	Reason string // Human-readable reason for the failure
}

func (e *ValidationError) Error() string {
	return fmt.Sprintf("validation failed for %s: %s", e.Field, e.Reason)
}

// GPGError represents a GPG operation failure with stderr output
type GPGError struct {
	Operation string // The GPG operation that failed (e.g., "encrypt", "decrypt")
	Stderr    string // Standard error output from GPG
	Err       error  // Underlying error
}

func (e *GPGError) Error() string {
	if e.Stderr != "" {
		return fmt.Sprintf("%s failed: %v (stderr: %s)", e.Operation, e.Err, e.Stderr)
	}
	return fmt.Sprintf("%s failed: %v", e.Operation, e.Err)
}

// Unwrap returns the underlying error for error wrapping support
func (e *GPGError) Unwrap() error {
	return e.Err
}

func main() {
	// Defensive: Recover from panics to provide a clean error message
	defer func() {
		if r := recover(); r != nil {
			fmt.Fprintf(os.Stderr, "Fatal error: %v\n", r)
			os.Exit(ExitUsage)
		}
	}()

	// Parse command-line flags
	encMode := flag.Bool("e", false, "encrypt mode")
	decMode := flag.Bool("d", false, "decrypt mode")
	help := flag.Bool("help", false, "show help message")
	flag.Parse()

	// Show help and exit successfully
	if *help {
		printUsage()
		os.Exit(ExitSuccess)
	}

	// Execute the main logic and handle errors
	if err := run(*encMode, *decMode, flag.Args()); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(getExitCode(err))
	}
}

// run contains the main application logic, separated for testability
func run(encMode, decMode bool, args []string) error {
	// Ensure exactly one mode is specified
	if (encMode && decMode) || (!encMode && !decMode) {
		printUsage()
		return errors.New("must specify exactly one of -e or -d")
	}

	// Locate the GPG executable
	gpg, err := findGPG()
	if err != nil {
		return fmt.Errorf("gpg not found: %w", err)
	}

	// Route to the appropriate mode handler
	if encMode {
		return runEncrypt(gpg, args)
	}
	return runDecrypt(gpg, args)
}

// runEncrypt handles encryption mode: notioncrypt -e <key> <plaintext>
func runEncrypt(gpg string, args []string) error {
	// Encryption mode requires exactly 2 arguments
	if len(args) != 2 {
		printUsage()
		return errors.New("encrypt mode requires exactly 2 arguments: <public_key> <plaintext>")
	}

	key := args[0]
	plaintext := args[1]

	// Validate inputs before attempting encryption
	if err := validateEncryptInputs(key, plaintext); err != nil {
		return err
	}

	// Perform encryption and write ASCII-armored output to stdout
	return encrypt(gpg, key, plaintext)
}

// runDecrypt handles decryption mode: notioncrypt -d <key> (reads from stdin)
func runDecrypt(gpg string, args []string) error {
	// Decryption mode requires exactly 1 argument
	if len(args) != 1 {
		printUsage()
		return errors.New("decrypt mode requires exactly 1 argument: <private_key>")
	}

	key := args[0]
	if err := validateKey(key); err != nil {
		return err
	}

	// Read ciphertext from stdin with size limit (+1 to detect overflow)
	data, err := io.ReadAll(io.LimitReader(os.Stdin, maxCiphertextBytes+1))
	if err != nil {
		return fmt.Errorf("failed to read stdin: %w", err)
	}

	// Defensive: Verify we didn't exceed the maximum size
	if len(data) > maxCiphertextBytes {
		return fmt.Errorf("ciphertext exceeds maximum size of %d bytes", maxCiphertextBytes)
	}

	// Ensure we received some data to decrypt
	if len(data) == 0 {
		return errors.New("no ciphertext provided on stdin")
	}

	// Perform decryption and write plaintext to stdout
	return decrypt(gpg, key, data)
}

// validateKey validates the key parameter (file path or key ID)
// Accepts both key file paths and GPG key IDs
func validateKey(key string) error {
	// Key cannot be empty
	if key == "" {
		return &ValidationError{"key", "cannot be empty"}
	}

	// Key cannot be only whitespace
	if strings.TrimSpace(key) == "" {
		return &ValidationError{"key", "cannot be whitespace only"}
	}

	// Enforce maximum length to prevent resource exhaustion
	if len(key) > maxKeyLength {
		return &ValidationError{"key", fmt.Sprintf("exceeds maximum length of %d characters", maxKeyLength)}
	}

	// Defensive: Reject null bytes which can cause security issues
	if strings.ContainsRune(key, 0) {
		return &ValidationError{"key", "contains null bytes"}
	}

	// Defensive: Ensure valid UTF-8 encoding
	if !utf8.ValidString(key) {
		return &ValidationError{"key", "contains invalid UTF-8 characters"}
	}

	// If it's not a file path, validate as a potential key ID
	if _, err := os.Stat(key); err != nil {
		// Appears to be a key ID rather than a file
		trimmed := strings.TrimSpace(key)
		
		// GPG key IDs have a minimum length
		if len(trimmed) < minGPGKeyIDLength {
			return &ValidationError{"key", fmt.Sprintf("key ID must be at least %d characters", minGPGKeyIDLength)}
		}
		
		// Defensive: Reject key IDs with control characters
		if strings.ContainsAny(trimmed, "\n\r\t") {
			return &ValidationError{"key", "key ID contains invalid whitespace characters"}
		}
	}

	return nil
}

// validateEncryptInputs validates all inputs for encryption mode
func validateEncryptInputs(key, plaintext string) error {
	// Validate the key first
	if err := validateKey(key); err != nil {
		return err
	}

	// Plaintext can be whitespace-only, but cannot be empty (zero length)
	// This allows encrypting strings like "   " or "\t\n" which may be valid use cases
	if len(plaintext) == 0 {
		return &ValidationError{"plaintext", "cannot be empty"}
	}

	// Enforce maximum plaintext size
	if len(plaintext) > maxPlaintextBytes {
		return &ValidationError{"plaintext", fmt.Sprintf("exceeds maximum size of %d bytes", maxPlaintextBytes)}
	}

	// Defensive: Reject null bytes in plaintext
	if strings.ContainsRune(plaintext, 0) {
		return &ValidationError{"plaintext", "contains null bytes"}
	}

	// Defensive: Ensure plaintext is valid UTF-8
	if !utf8.ValidString(plaintext) {
		return &ValidationError{"plaintext", "contains invalid UTF-8 characters"}
	}

	return nil
}

// getExitCode maps errors to appropriate exit codes for shell scripting
func getExitCode(err error) int {
	if err == nil {
		return ExitSuccess
	}

	// Check for validation errors
	var valErr *ValidationError
	if errors.As(err, &valErr) {
		if valErr.Field == "plaintext" {
			// Plaintext length issues use ExitLengthInvalid
			if strings.Contains(valErr.Reason, "empty") {
				return ExitLengthInvalid
			}
			if strings.Contains(valErr.Reason, "exceeds") {
				return ExitLengthInvalid
			}
		}
		// Other validation errors use ExitFormatInvalid
		return ExitFormatInvalid
	}

	// Check for GPG operation errors
	var gpgErr *GPGError
	if errors.As(err, &gpgErr) {
		if gpgErr.Operation == "encrypt" {
			return ExitEncryptFail
		}
		if gpgErr.Operation == "decrypt" {
			return ExitDecryptFail
		}
	}

	// Fallback: pattern match error messages
	errMsg := err.Error()
	if strings.Contains(errMsg, "gpg not found") {
		return ExitGPGNotFound
	}
	if strings.Contains(errMsg, "read stdin") {
		return ExitReadFail
	}
	if strings.Contains(errMsg, "no ciphertext") {
		return ExitNoCiphertext
	}
	if strings.Contains(errMsg, "encrypt") {
		return ExitEncryptFail
	}
	if strings.Contains(errMsg, "decrypt") {
		return ExitDecryptFail
	}

	// Default to usage error
	return ExitUsage
}

// printUsage displays comprehensive usage information
func printUsage() {
	fmt.Println(`notioncrypt - lightweight GPG-based encryption helper

Usage:
  notioncrypt -e <public_key> <plaintext>
      Encrypt plaintext with a GPG public key ID.
      Output is ASCII-armored and written to stdout.

  notioncrypt -d <private_key>
      Decrypt ciphertext from stdin using a GPG private key ID.
      Output plaintext is written to stdout.

Options:
  -e        Encrypt mode. Requires <public_key> and <plaintext>.
  -d        Decrypt mode. Requires <private_key> and reads ciphertext from stdin.
  --help    Show this help message.

Arguments:
  <public_key>   Public key file path or GPG key ID for encryption
  <private_key>  Private key file path or GPG key ID for decryption
  <plaintext>    Text to encrypt (can be whitespace-only, but not empty)

Format rules:
  1. If plaintext contains whitespace, wrap it in quotes for your shell.
  2. Plaintext can be whitespace-only but must not be zero-length.
  3. Maximum plaintext size: 8 KB.
  4. Maximum ciphertext size: 64 KB.
  5. Keys and plaintext must be valid UTF-8 without null bytes.

Examples:
  # Encrypt with key ID and copy to clipboard
  notioncrypt -e mykey "hello world" | pbcopy
  
  # Decrypt from clipboard
  pbpaste | notioncrypt -d mykey

  # Encrypt and decrypt with an asc file
  notioncrypt -e mykey mypassword > ./temp.asc
  cat ./temp.asc | notioncrypt -d mykey
  
Error codes:
  0  Success
  1  Invalid usage or arguments
  2  GPG not found in PATH
  3  Invalid format
  4  Invalid length
  5  Encryption failed
  6  Failed to read stdin
  7  No ciphertext provided
  8  Decryption failed
`)
}

// findGPG locates the GPG executable in PATH
// Tries both "gpg" and "gpg2" and verifies the binary is executable
func findGPG() (string, error) {
	for _, name := range []string{"gpg", "gpg2"} {
		if name == "" {
			continue // Defensive: skip empty names
		}
		
		// Look for the executable in PATH
		path, err := exec.LookPath(name)
		if err == nil {
			// Defensive: verify the path is not empty
			if path == "" {
				continue
			}
			
			// Defensive: verify the file exists and is executable
			if fi, err := os.Stat(path); err == nil {
				// Check if it's a regular file with execute permission
				if fi.Mode().IsRegular() && (fi.Mode().Perm()&0111 != 0) {
					return path, nil
				}
			}
		}
	}
	return "", errors.New("gpg executable not found in PATH")
}

// importKey imports a GPG key from a file and returns its key ID
// The key file can be in ASCII-armored or binary format
func importKey(gpg, file string) (string, error) {
	// Defensive: validate inputs
	if gpg == "" {
		return "", errors.New("gpg path is empty")
	}
	if file == "" {
		return "", errors.New("key file path is empty")
	}

	// Resolve to absolute path
	path, err := filepath.Abs(file)
	if err != nil {
		return "", fmt.Errorf("failed to resolve key file path: %w", err)
	}

	// Defensive: verify the key file before importing
	fi, err := os.Stat(path)
	if err != nil {
		return "", fmt.Errorf("cannot access key file: %w", err)
	}
	
	// Ensure it's a regular file (not a directory, device, socket, etc.)
	if !fi.Mode().IsRegular() {
		return "", errors.New("key file is not a regular file")
	}
	
	// Reject empty files
	if fi.Size() == 0 {
		return "", errors.New("key file is empty")
	}
	
	// Defensive: limit key file size to prevent DoS
	if fi.Size() > maxKeyFileSize {
		return "", fmt.Errorf("key file is too large (max %d bytes)", maxKeyFileSize)
	}

	// Import the key into GPG keyring
	var stderr bytes.Buffer
	cmd := exec.Command(gpg, "--import", path)
	cmd.Stderr = &stderr
	cmd.Stdin = nil // Defensive: ensure no stdin interaction

	if err := cmd.Run(); err != nil {
		return "", &GPGError{
			Operation: "import key",
			Stderr:    stderr.String(),
			Err:       err,
		}
	}

	// Parse and return the key ID from the imported key
	return parseKeyID(gpg, path)
}

// parseKeyID extracts the key ID from a GPG key file
// Returns the first public (pub) or secret (sec) key ID found
func parseKeyID(gpg, path string) (string, error) {
	// Defensive: validate inputs
	if gpg == "" || path == "" {
		return "", errors.New("invalid arguments to parseKeyID")
	}

	// Run GPG with machine-readable output format
	cmd := exec.Command(gpg, "--with-colons", path)
	cmd.Stdin = nil // Defensive: no stdin needed
	
	out, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to parse key ID: %w", err)
	}

	// Defensive: ensure GPG returned some output
	if len(out) == 0 {
		return "", errors.New("gpg returned empty output")
	}

	// Parse the colon-separated output format
	scanner := bufio.NewScanner(bytes.NewReader(out))
	
	// Defensive: set maximum line length to prevent memory exhaustion
	const maxScanTokenSize = 64 * 1024
	buf := make([]byte, maxScanTokenSize)
	scanner.Buffer(buf, maxScanTokenSize)

	// Look for pub (public key) or sec (secret key) lines
	for scanner.Scan() {
		line := scanner.Text()
		if line == "" {
			continue
		}

		// Parse colon-separated fields
		parts := strings.Split(line, ":")
		
		// Field 0 is the record type, field 4 is the key ID
		if len(parts) >= 5 && (parts[0] == "pub" || parts[0] == "sec") {
			keyID := strings.TrimSpace(parts[4])
			
			// Validate the key ID before returning
			if keyID != "" && len(keyID) >= minGPGKeyIDLength {
				return keyID, nil
			}
		}
	}

	// Check for scanner errors
	if err := scanner.Err(); err != nil {
		return "", fmt.Errorf("error reading key output: %w", err)
	}

	// No valid key ID found in the file
	return "", errors.New("no valid key ID found in file")
}

// encrypt encrypts plaintext using GPG with the specified public key
// Output is ASCII-armored and written to stdout
func encrypt(gpg, key, text string) error {
	// Defensive: validate gpg path
	if gpg == "" {
		return errors.New("gpg path is empty")
	}

	// Resolve the recipient (import key file if needed, or use key ID directly)
	recipient, err := resolveRecipient(gpg, key)
	if err != nil {
		return err
	}

	// Defensive: ensure we have a valid recipient
	if recipient == "" {
		return errors.New("recipient is empty after resolution")
	}

	// Create context with timeout to prevent hanging
	ctx, cancel := context.WithTimeout(context.Background(), gpgTimeout)
	defer cancel()

	// Execute GPG encryption
	var stderr bytes.Buffer
	cmd := exec.CommandContext(ctx, gpg, "--armor", "--encrypt", "--recipient", recipient)
	cmd.Stdin = strings.NewReader(text)
	cmd.Stdout = os.Stdout // Write encrypted output to stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		// Defensive: check if the operation timed out
		if ctx.Err() == context.DeadlineExceeded {
			return &GPGError{
				Operation: "encrypt",
				Stderr:    "operation timed out",
				Err:       ctx.Err(),
			}
		}
		return &GPGError{
			Operation: "encrypt",
			Stderr:    stderr.String(),
			Err:       err,
		}
	}

	return nil
}

// decrypt decrypts ciphertext using GPG with the specified private key
// Output plaintext is written to stdout
func decrypt(gpg, key string, data []byte) error {
	// Defensive: validate inputs
	if gpg == "" {
		return errors.New("gpg path is empty")
	}
	if len(data) == 0 {
		return errors.New("ciphertext data is empty")
	}

	// Import the private key if it's a file
	if err := prepareDecryptKey(gpg, key); err != nil {
		return err
	}

	// Create context with timeout to prevent hanging
	ctx, cancel := context.WithTimeout(context.Background(), gpgTimeout)
	defer cancel()

	// Execute GPG decryption
	var stderr bytes.Buffer
	cmd := exec.CommandContext(ctx, gpg, "--quiet", "--batch", "--yes", "--decrypt")
	cmd.Stdin = bytes.NewReader(data)
	cmd.Stdout = os.Stdout // Write decrypted output to stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		// Defensive: check if the operation timed out
		if ctx.Err() == context.DeadlineExceeded {
			return &GPGError{
				Operation: "decrypt",
				Stderr:    "operation timed out",
				Err:       ctx.Err(),
			}
		}
		return &GPGError{
			Operation: "decrypt",
			Stderr:    stderr.String(),
			Err:       err,
		}
	}

	return nil
}

// resolveRecipient determines the recipient ID for encryption
// If key is a file path, imports it and returns the key ID
// If key is already a key ID, returns it as-is
func resolveRecipient(gpg, key string) (string, error) {
	// Defensive: check for empty key
	if key == "" {
		return "", errors.New("key is empty")
	}

	// Check if the key is a file path
	fi, err := os.Stat(key)
	if err == nil && fi.Mode().IsRegular() {
		// It's a file, import it and get the key ID
		return importKey(gpg, key)
	}
	
	// It's not a file, assume it's a key ID and return as-is
	return key, nil
}

// prepareDecryptKey imports the decryption key if it's a file
// Does nothing if the key is already a key ID
func prepareDecryptKey(gpg, key string) error {
	// Defensive: check for empty key
	if key == "" {
		return errors.New("key is empty")
	}

	// Check if the key is a file path
	fi, err := os.Stat(key)
	if err == nil && fi.Mode().IsRegular() {
		// It's a file, import it (we don't need the returned key ID)
		_, err := importKey(gpg, key)
		return err
	}
	
	// It's not a file, assume it's already in the keyring
	return nil
}
\end{lstlisting}
\end{document}
